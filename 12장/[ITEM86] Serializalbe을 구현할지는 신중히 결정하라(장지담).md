어떤 클래스의 객체를 직렬화 할 수 있게 하려면 클래스 선언에 implements Serializable을 붙이면 된다. 간단하지만 사실은 신경쓸 내용이 많다. 

# Serializable을 구현하면 릴리스 한 뒤에는 수정하기 어렵다
- 클래스가 Serializable을 구현하면 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 api가 된다. 즉 직렬화 형태를 영원히 지원해야 한다.
- 자바의 기본 방식을 사용하면 클래스의 private, package-private 인스턴스 필드들마저 API로 공개된다. 캡슐화가 깨진다.
- 내부 구현을 손보면 원래의 직렬화 형태와 달라진다.
- 직렬화 가능 클래스를 만들고자 한다면 고품질의 직렬화 형태도 주의해서 함께 설계해야 한다.

### 직렬화가 클래스 개선을 방해하는 예시
- 모든 직렬화딘 클래스는 static final long serialVersionUID 필드로 고유 식별 번호를 부여받는다.
- 따로 명시하지 않으면 자동으로 시스템이 생성해 넣는다.
- 값 생성에는 클래스 이름, 구현한 인터페이스들, 컴파일러가 생성해 넣은 것 등 대부분이 고려된다.
- 추후에 클래스를 수정(개선)한다면 serialVersionUID값이 변경되어 호환성이 깨진다.

# 버그와 보안 구멍이 생길 위험이 높아진다 
- 객체는 원래 생성자를 통해 만들어야 하지만 역직렬화는 그렇지 않다.
- 생성자에서 정한 불변식과 공격자로부터의 보호를 받기 어렵다.
- 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다.

# 클래스의 신버전을 릴리스할 때 테스트 할 것이 늘어난다 
- 신버전 인스턴스 직렬화 -> 구버전 역직렬화, 구버전 인스턴스 직렬화 -> 신버전 역직렬화가 가능한지 테스트해야 한다
- 릴리스 횟수이 비례해 테스트 양이 증가한다

---

# Serializable 구현 여부를 신중히 결정하자 
- 객체를 전송하거나 저장할 때 자바 직렬화를 이용하는 프레임워크를 위한 클래스거나, Serializable을 반드시 구현해야 하는 다른 클래스의 컴포넌트로 쓰일 때는 어쩔 수 없다.
- 클래스를 설계할 때 마다 Serializable 구현의 이득-비용을 저울질하자.
- 역사적으로 BigInteger 같은 값 클래스, 컬렉션 클래스는 Serializable을 구현하고 스레드 풀 처럼 동작하는 객체를 표현하는 클래스는 구현하지 않았다. 

# 상속용 클래스는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 안된다. 
- 클래스 확장자나 인터페이스 구현자에게 큰 부담이다.
- Throwable : 서버가 RMI를 통해 클라이언트에게 예외를 보내기 위해 구현
- Component : GUI 전송, 복원을 위해 구현

### 상속용 클래스를 직렬화 가능하게 만들 때 주의점 
1. 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 하위 클래스에서 finalize를 재정의하지 못하게 하자
- finalize를 자신이 재정의하면서 final로 선언하자
- 이렇게 하지 않으면 finalizer 공격을 당할 수 있다

2. 인스턴스 필드 중 기본값(0, false, null)로 초기화되면 위배되는 불변식이  있다면 클래스에 readObjectNodata 메서드를 추가하자.
```java
    private void readobjectNoData() throws InvalidObjectException {
        throw new InvalidObjectException("스트림 데이터가 필요합니다");
    }
```
직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 경우를 위한 메서드다. 

- Serializable을 구현하지 않기로 결정하면 하위 클래스에서 직렬화를 지원하려 할 때 부담이 늘어난다.
- 상위 클래스가 기본 생성자를 제공하지 않으면 하위 클래스에서는 직렬화 프록시 패턴을 사용해야 한다.

# 내부 클래스는 직렬화를 구현하지 말아야 한다.
- 내부 클래스에는 바깥 인스턴스 참조, 유효 범위 안의 지역변수를 저장하기 위해 컴파일러가 생성한 필드들이 자동 추가된다.
- 이 필드들이 클래스 정의에 어떻게 추가되는지 정의되지 않아서 내부 클래스에 대한 기본 직렬화 형태가 불분명하다.
- static 멤버 클래스는 Seralizable을 구현해도 된다.


