# ITEM85

## p.450

> 프로그래머가 어렵지 않게 분산 객체를 만들 수 있다는 구호는 매력적이었지만,

여기서 `분산 객체`의 정확한 정의가 무엇인가요? 직렬화 대상이 되는 객체를 말하는 것인가요?

## p.452

> 이 객체 그래프는 201개의 HashSet 인스턴스로 구성되며, 그 각각은 3개 이하의 객체 참조를 갖는다.

root, s2에서 HashSet 인스턴스가 각각 하나씩 만들어지고 100번을 반복하는 반복문내에서 t1, t2 각각의 HashSet 인스턴스가 만들어지니 200개의 인스턴스가 만들어진다고 생각합니다. 그렇다면 총합은 202라고 생각했는데 왜 201인가요?!

# ITEM87

## 코드 87-3

> //이제는 직렬화되지 않는다.

`Entry`가 직렬화되지 않는 이유는 위의 `head` 필드에 있는 transient 한정자 때문인가요?

## p.464

> 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야한다.

객체의 논리적 상태와 무관한 필드가 클래스 내애 같이 묶여있는 경우가 있을까요? 위와 같이 transient 한정자를 생략하는 경우는 어떤 경우인지 예시가 궁금합니다. 
## p.465

> 직렬 버전 UID가 꼭 고유할 필요는 없다.

보통 UID 들은 고유한 것으로 알고 있는데 직렬 버전 UID가 고유하지 않아도 되는 이유는 뭔가요?
# ITEM90

## p.480

> 하지만 공격자는 불변식을 훼손하고자 이런 시도를 해볼 수 있다.

위에서 `이런 시도`란 바깥 클래스의 직렬화된 인스턴스를 생성하는 것을 뜻하는 걸까요?
