# ITEM85

## p.450

> 프로그래머가 어렵지 않게 분산 객체를 만들 수 있다는 구호는 매력적이었지만,

여기서 `분산 객체`의 정확한 정의가 무엇인가요? 직렬화 대상이 되는 객체를 말하는 것인가요?

### answer
- 직렬화란? 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용 할수 있도록 바이트 스트림(stream of bytes) 형태로 연속전인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫습니다.
- 분산객체란? 여러 대의 컴퓨터에 분산 배치되어 네트워크로 연결되어 함께 동작하거나, 동일한 컴퓨터에서 여러 프로세스들이 함께 동작하는 소프트웨어 모듈을 말합니다.

따라서 여기서 분산 객체는 직렬화 대상을 말하는 것이 맞다고 생각합니다!

## p.452

> 이 객체 그래프는 201개의 HashSet 인스턴스로 구성되며, 그 각각은 3개 이하의 객체 참조를 갖는다.

root, s2에서 HashSet 인스턴스가 각각 하나씩 만들어지고 100번을 반복하는 반복문내에서 t1, t2 각각의 HashSet 인스턴스가 만들어지니 200개의 인스턴스가 만들어진다고 생각합니다. 그렇다면 총합은 202라고 생각했는데 왜 201인가요?!

### answer


# ITEM87

## 코드 87-3

> //이제는 직렬화되지 않는다.

`Entry`가 직렬화되지 않는 이유는 위의 `head` 필드에 있는 transient 한정자 때문인가요?

### answer
writeObject를 명시적으로 정의했기 때문이고 transient는 그것을 표시해주는 역할이라고 생각합니다.

## p.464

> 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야한다.

객체의 논리적 상태와 무관한 필드가 클래스 내애 같이 묶여있는 경우가 있을까요? 위와 같이 transient 한정자를 생략하는 경우는 어떤 경우인지 예시가 궁금합니다. 

### answer
```java
public class Person {
    private int id; // 논리적 상태와 무관한 필드
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
```
객체의 논리적 상태는 사람의 이름과 나이이지만 id는 논리적 상태가 아니므로 예시가 될 수 있다고 생각합니다. 

## p.465

> 직렬 버전 UID가 꼭 고유할 필요는 없다.

보통 UID 들은 고유한 것으로 알고 있는데 직렬 버전 UID가 고유하지 않아도 되는 이유는 뭔가요?

### answer
이 uid는 버전 관리를 위한 것이므로 다른 클래스간에는 고유하지 않아도 된다고 생각합니다! 

# ITEM90

## p.480

> 하지만 공격자는 불변식을 훼손하고자 이런 시도를 해볼 수 있다.

위에서 `이런 시도`란 바깥 클래스의 직렬화된 인스턴스를 생성하는 것을 뜻하는 걸까요?

### answer
네 왜냐하면 readObject를 호출하면 되니까요. 따라서 책에서는 readObject에서 예외를 던져셔 막는 방법을 알려주고 있습니다. 
