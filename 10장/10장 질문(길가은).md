# ITEM74

## p.403

> 클래스를 수정하면서 새로운 비검사 예외를 던지게 되어도 소스 호환성과 바이너리 호환성이 그대로 유지된다는 게 가장 큰 이유다.

여기서 `소스 호환성`과 `바이너리 호환성` 각각의 정확한 정의와 차이점은 무엇이고, **왜 클래스를 수정해도 유지되나요?**

### answer
**바이너리 호환성** 
- 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황을 바이너리 호환성이라고 한다. (자바에서 바이너리는 클래스파일을 의미합니다)예를들어 인터페이스에 메소드를 추가했을 때 추가된 메소드를 호출하지 않는 한 문제가 일어나지 않는데 이를 바이너리 호환성이라고 한다.
- chatgpt) Java에서 "바이너리 호환성"은 기존에 컴파일된 바이트 코드(Java 클래스 파일)가 새로운 버전의 Java Virtual Machine(JVM)에서도 정상적으로 실행될 수 있는 능력을 의미합니다. 간단히 말해, 한 버전에서 컴파일된 Java 프로그램이 다른 Java 버전에서도 동작하는 능력을 말합니다.

**소스 호환성**
- 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일 할 수 있는 것이다. 
- chatgpt) Java에서 "소스 호환성"은 Java 코드가 다양한 Java 버전의 컴파일러에서 컴파일되고 실행될 수 있는 능력을 나타냅니다. 즉, 소스 코드가 어떤 버전의 Java 컴파일러에서도 문제 없이 빌드되고 실행될 수 있도록 하는 것을 의미합니다.

출처 ㅣ https://clearpal7.blogspot.com/2017/03/8_56.html

![image](https://github.com/rlfrkdms1/effective-java-study/assets/96513365/cfbdfa2f-3a08-40c1-8812-017311b07094)

클래스를 수정하더라도 위 경우들에는 바이너리 호환성이 지켜진다고 합니다. 


# ITEM75

## p.404

> 사이트 신뢰성 엔지니어(site reliability engineer)

사이트 신뢰성 엔지니어란 어떤일을 하는 엔지니어인가요?

# ITEM76

## p.408

> 따라서 `ConcurrentModificationException`을 잡아냈다고 해서 그 객체가 여전히 쓸 수 있는 상태라고 가정해서는 안 된다.

그렇다면 어떻게 예외를 잡아내어 객체를 여전히 사용할 수 있다고 판단할 수 있나요?

> Error는 복구할 수 없으므로 `AssertionErro`에 대해서는 실패 원자적으로 만들려는 시도조차 할 필요가 없다.

여기서 말하는 Error가 정확히 무엇인가요? 왜 복구할 수 없나요?
