# ITEM15
> 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 상수라면 public static final 필드로 공개해도 좋다.

` 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 상수` 의 예시가 뭐가 있을까요?


# ITEM17
> 클래스를 설계할 때 public 생성자 대신 정적 팩터리를 만들어두면 클라이언트르 수정하지 않고도 캐시 기능을 나중에 덧붙일 수 있다.

 저는 정적 팩터리 메서드 내부에서 캐시된 객체를 반환하도록 하면 된다고 생각했는데 맞을까요?

 ---
 
 
> 불변 필드가 가변 객체를 가리키더라도 공유할 수 있다.

불변 필드가 가변 객체를 가리킬 때, 필드의 참조를 못바꾸는 것이지 참조를 통해 가변 객체에 변경을 가할 수 있는 걸로 아는데 왜 공유해도 되나요?

---


> 클래스가 불변임을 보장하려면 final로 선언해서 상속하지 못하게 해야 한다. 더 유연한 방법으로 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리르 제공하는 방법이다.

후자가 왜 더 유연한 방식인가요?

 
# ITEM18
> 래퍼 클래스 단점은 콜백 프레임워크와 어울리지 않는다는 점이다. 콜백 프레임워크에서는 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출(콜백) 때 사용하도록 한다. 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르기 때문에 자신의 참조를 넘기고, 콜백 때는 래퍼가 아닌 내부 객체를 호출하게 된다. 이것을 SELF 문제라 한다

예를 들면 어떤 상황이 이에 해당할까요?


# ITEM19
> 핵심 기능을 정의한 인터페이스가 있고, 클래스가 그 인터페이스를 구현했다면 상속을 금지해도 개발하는데 어려움이 없다.

이 이유가 무엇인가요? 



# ITEM20
>  인터페이스를 구현한 클래스는 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

이게 무슨 뜻인가요?

---

> 기존 클래스에도 손쉽게 인터페이스를 구현해넣을 수 있다. 인터페이스가 요구하는 메서드를 구현하고 클래스 선언에 implements 구문을 추가하면 된다. 하지만 클래스 위에 새로운 추상 클래스를 끼워넣기는 어렵다. 두 클래스가 같은 추상 클래스를 확장하길 원한다면 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다. 이 방식은 클래스 계층구조에 커다란 혼란을 일으킨다. 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 된다

이게 왜 문제가 되는건가요? 상속하는 관계일떄만 추상 클래스를 추가하면 되는거 아닌가요?

---

> Object의 메서드를 정의한 경우 (equals, hashCode 등), 디폴트 메서드로 제공해서는 안된다.

왜 안되나요?

---

> 골격 구현 클래스 작성 방법에서.. 인터페이스에서 다른 메서드들의 구현에 사용되는 기반 메서드를 선정한다. 기반 메서드들은 골격 구현 클래스에서 추상 메서드가 된다.

```java
public interface Interface {
    // 기반 메서드
    void a();

    // 디폴트 메서드
    default  void b(){
        // 기반 메서드를 사용해 직접 구현한다.
        System.out.println("a");
        a();
    }

    // 기반 메서드나 디폴트 메서드가 아닌 메서드
    void c();
}

public abstract class AbstractInterface implements Interface{

    // 기반 메서드, 디폴트 메서도 아닌 메서드는 골격 구현 클래스에서 구현한다.
    @Override
    public void c() {
        System.out.println("c");
    }
}

public class ConcreteClass extends AbstractInterface {
    // 기반 메서드는 구체 클래스에서 구현한다. 
    @Override
    public void a() {
        System.out.println("a");
    }
}
```
저는 위 내용을 인터페이스의 기반 메서드를 골격 구현 클래스에서 메서드를 다시 선언할 필요는 없고 골격 구현 클래스를 구현하는 구체 클래스에서 기반 메서드를 구현한다. 는 것으로 이해했습니다. 코드로 작성해보기도 했고요. 이게 맞나요??


# ITEM24
비정적 멤버 클래스에서
> 바깥 클래스와 비정적 멤버 클래스의 관계는 멤버 클래스 객체가 생성될 때 확립되며 더이상 변경할 수 없다.

라고 하는데 `바깥 클래스와 비정적 멤버 클래스의 관계`가 정확히 무엇인가요?
