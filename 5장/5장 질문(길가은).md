# ITEM 30

p.178
> T가 어떤 타입이든 `UnaryOperator<Object>`는 `UnaryOperator<T>`가 아니기 때문이다

# ITEM 31
p.181
> `List<String>`은 `List<Object>`의 하위 타입이 아니라는 뜻인데, ~ 즉, `List<String>`은 `List<Object>`가 하는 일을 제대로 수행하지 못하니 하위 타입이 될 수 없다.

그렇다면 `List<Object>`는 왜 `List<String>`의 하위 타입이 되지 못하나요? `List<Object>`는 모든 것을 넣을 수 있어 `String`도 넣을 수 있는데,, 책에서도 직관적이지 않다고 했는데 그래서 그런지 와닿지 않는 것 같아요.

p.182
> 매개변수화 타입이 불공변이기 때문이다.

불공변은 `List<type1>`이 `List<type2>`의 하위 타입도, 상위 타입도 아니라고 정의되었는데, 여기서 왜 매개변수화 타입이 불공변인지 모르겠습니다. 
그리고 불공변에 관한 정확한 정의에 대해 잘 모르겠습니다.

p.183
> `Collection<Object>`는 `Collection<Numer>`의 하위 타입이 아니다

이것 또한 불공변이기 때문인가요 ?

p.185

> 클라이언트 코드에서도 와일드카드 타입을 써야하기 때문이다.

잘 이해가 안되는 것 같아요. 예시가 궁금해요.

p.187

> `Comparable`은 언제나 소비자이므로,

왜 항상 소비자인가요? `Comparable`을 사용하는 인스턴스에게 max에 해당하는 인스턴스를 만들어주니까 생산자라고 생각할 수도 있지 않나요?

# ITEM 32

p.192

> //힙 오염 발생

왜 힙 오염이 발생하나요?

> 컴파일러가 생성한 형변환이 숨어있기 때문이다.

어떤 형변환인가요?

p. 193

> 그 시점에는 컴파일러에게 충분한 정보가 주어지지 않아 타입을 잘못 판단할 수 있다.

왜 그런가요 ? 

