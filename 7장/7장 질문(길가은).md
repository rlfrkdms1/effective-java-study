# ITEM 46

## P.278

> 종단 연산

종단 연산이란 무엇인가요?

_**ANSWER**_ 

종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가하는 것으로 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를  출력하는 것입니다. forEach가 대표적인 종단연산입니다. 

## P.282

> 이 메서드는 점층적 인수 목록 패턴에 어긋난다.

해당 패턴에 어긋나면 어떤 단점이 존재하나요?

_**ANSWER**_ 

점층적 인수 목록 패턴은 ITEM2에서 소개한 점층적 생성자 패턴을 말하는 것 같습니다.(구글링 해도 `점층적 인수 목록 패턴` 이라는 말은 안나옴) 점층적 생성자 패턴은 필수 매개변수를 지정하고 선택 매개변수를 하나씩 늘리며 생성자를 만드는 방식인데, 
사용자는 downStream 매개변수 뒤에 mapFactory 매개변수가 올 것을 기대하겠지만, 그것이 어긋나 부자연스럽고 메서드 시그니처를 확인해봐야 한다는 단점이 있습니다. 

> 분류함수 자리에 predicate를 받고 키가 Boolean인 맵을 반환한다.

predicate가 정확히 어떤건가요?

_**ANSWER**_ 

Predicate는 인수를 하나 받아 boolean을 반환하는 메서드가 선언되어 있는 함수형 인터페이스입니다. 

# ITEM 47

## P.284

> for-each에서만 쓰이거나 반환된 원소 시퀀스가 일부 Collction메서드를 구현할 수 없을 때는 Iterable 인터페이스를 썼다.

어떤 경우인가요 ? 예시가 궁금해요. 

## P.286

> 단지 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올려서는 안된다.

그럼 덩치 큰 시퀀스는 어떻게 해야하나요?

_**ANSWER**_

책에서 소개하는 것처럼 가능하다면 전용 컬렉션 구현을 고려해서 메모리를 절약할 수 있습니다.

## P.288

> 하지만 이 컬렉션은 입력 리스트크기의 거듭제곱만큼 메모리를 차지한다.

왜 거듭제곱만큼 메모리를 차지하나요?

_**ANSWER**_

입력 리스트가 길이 N이라면 연속적인 부분리스트는 



