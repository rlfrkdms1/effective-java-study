# ITEM38

## p.232

> 타입 안전 열거 패턴 (typesafe enum pattern)

타입안전 열거패턴이 무엇인가요?

> 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않는다면 이상하지 않은가!

확장한 타입이라는 것이 상속을 받은 자식 클래스라는 것으로 여겨지는데, 자식 클래스의 원소는 부모 클래스의 원소로도 취급하지만 부모 클래스의 원소는 자식 클래스의 원소로 취급되지 않는다는 뜻인가요?
상속은 부모 클래스의 필드들을 가지고 올 수 있는 것인데, 그렇다면 역이 성립되어야 하는 건 아닌지 헷갈립니다 ㅜ
바로 뒤에 나오는 `기반 타입과 확장된 타입들의 원소 모두를 순회할 방법도 마땅치 않다.` 또한 반대가 성립하지 않아서 그런건가요?

# ITEM39

## p.237

> 명명 패턴의 단점 두 번째는 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다는 것이다.

`TestSafetyMechanisms`로 클래스 이름을 짓고 메서드 이름엔 `test`를 붙이지 않아 개발자가 의도한 테스트가 수행되지 않았다는 것인가요? 

## p.238

> 적절한 애너테이션 처리기를 직접 구현해야 한다.

애너테이션 처리기는 무엇인가요?

> 해당 예외의 클래스 파일이 컴파일 타입에는 존재했으나 런타임에는 존재하지 않을 수는 있다.

어떤 경우인가요? 런타임 중, 클래스 파일을 삭제한 경우인가요?


